// lib/strava.js
import { getActivityLaps } from "./strava-service";
/**
 * Extrait l'allure moyenne et le temps de r√©cup√©ration d'une description d'activit√©
 * @param {string} description - La description g√©n√©r√©e de l'activit√©
 * @returns {Object} - Objet contenant l'allure moyenne et le temps de r√©cup√©ration
 */
export function extractStatsFromDescription(description) {
  if (!description) {
    return { averagePace: null, recoveryTime: null };
  }

  const stats = {
    averagePace: null,
    recoveryTime: null,
  };

  // Extraire le temps de r√©cup√©ration entre les intervalles
  const recoveryMatch = description.match(/INTERVALLES \(R([^)]+)\)/);
  if (recoveryMatch && recoveryMatch[1]) {
    stats.recoveryTime = recoveryMatch[1];
  }

  // Extraire l'allure moyenne
  const averagePaceMatch = description.match(/MOYENNE: ([0-9:]+)\/km/);
  if (averagePaceMatch && averagePaceMatch[1]) {
    stats.averagePace = averagePaceMatch[1];
  }

  return stats;
}

/**
 * G√©n√®re un nouveau titre enrichi pour l'activit√© de fractionn√©
 * @param {string} originalTitle - Le titre original de l'activit√©
 * @param {Object} stats - Les statistiques extraites de la description
 * @returns {string} - Le nouveau titre format√©
 */
export function generateEnhancedTitle(originalTitle, stats) {
  if (!stats.averagePace) {
    return originalTitle;
  }

  let newTitle = originalTitle.trim();

  // Ajouter l'allure moyenne
  newTitle += ` | ${stats.averagePace}/km`;

  // Ajouter le temps de r√©cup√©ration si disponible
  if (stats.recoveryTime) {
    newTitle += ` | R${stats.recoveryTime}`;
  }

  return newTitle;
}

/**
 * D√©termine si l'activit√© doit √™tre analys√©e (fractionn√© vs endurance)
 */
export async function shouldProcessActivity(accessToken, activity) {
  console.log(`Analyzing activity: ${activity.name} (ID: ${activity.id})`);

  // Ne traiter que les activit√©s de type "Run"
  if (activity.type !== "Run") {
    console.log(`Skipping: Not a Run activity (${activity.type})`);
    return false;
  }

  // Ignorer les activit√©s d'endurance explicites
  if (activity.name.toLowerCase().includes("endurance")) {
    console.log("Skipping: Contains 'endurance' in name");
    return false;
  }

  // Si le nom indique clairement un fractionn√©, pas besoin d'aller plus loin
  const intervalPattern = /\d+\s*[xX]\s*\d+/;
  if (intervalPattern.test(activity.name)) {
    console.log(`Identified as interval by name pattern: ${activity.name}`);
    return true;
  }

  try {
    // R√©cup√©rer les laps
    console.log("Fetching laps...");
    const laps = await getActivityLaps(accessToken, activity.id);
    console.log(`Found ${laps.length} laps`);

    // Ignorer les laps tr√®s courts qui pourraient √™tre des artefacts
    const significantLaps = laps.filter(
      (lap) => lap.distance > 100 && lap.moving_time > 30
    );
    console.log(`${significantLaps.length} significant laps after filtering`);

    // S'il n'y a pas assez de laps pour analyser
    if (significantLaps.length < 2) {
      console.log("Not enough significant laps to analyze");
      return false;
    }

    // Calculer la vitesse moyenne pour chaque lap significatif
    const speeds = significantLaps.map((lap) => lap.average_speed);
    console.log("Speeds of laps:", speeds);

    const avgSpeed =
      speeds.reduce((sum, speed) => sum + speed, 0) / speeds.length;
    console.log("Average speed:", avgSpeed);

    // Trouver le lap le plus rapide
    const fastestLap = significantLaps.reduce(
      (fastest, lap) =>
        lap.average_speed > fastest.average_speed ? lap : fastest,
      significantLaps[0]
    );
    console.log("Fastest lap:", {
      index: fastestLap.lap_index,
      speed: fastestLap.average_speed,
      hr: fastestLap.average_heartrate,
    });

    // Trouver le lap le plus lent
    const slowestLap = significantLaps.reduce(
      (slowest, lap) =>
        lap.average_speed < slowest.average_speed ? lap : slowest,
      significantLaps[0]
    );
    console.log("Slowest lap:", {
      index: slowestLap.lap_index,
      speed: slowestLap.average_speed,
      hr: slowestLap.average_heartrate,
    });

    // Calculer la diff√©rence de vitesse entre le lap le plus rapide et le plus lent
    const speedDifference = fastestLap.average_speed - slowestLap.average_speed;
    console.log("Speed difference:", speedDifference);

    const speedRatio = fastestLap.average_speed / slowestLap.average_speed;
    console.log("Speed ratio:", speedRatio);

    // V√©rifier s'il y a un lap d'intensit√© significativement plus √©lev√©e
    // 1. La diff√©rence de vitesse est d'au moins 15%
    const hasSignificantSpeedDifference = speedDifference > avgSpeed * 0.15;
    console.log(
      "Has significant speed difference?",
      hasSignificantSpeedDifference,
      `(${speedDifference} > ${avgSpeed * 0.15})`
    );

    // 2. Le rapport entre la vitesse la plus √©lev√©e et la plus basse est au moins 1.2
    const hasSignificantSpeedRatio = speedRatio > 1.2;
    console.log(
      "Has significant speed ratio?",
      hasSignificantSpeedRatio,
      `(${speedRatio} > 1.2)`
    );

    // 3. V√©rifier les diff√©rences de fr√©quence cardiaque si disponibles
    let hasSignificantHrDifference = false;
    if (activity.has_heartrate) {
      const validHrLaps = significantLaps.filter(
        (lap) => lap.average_heartrate > 0
      );
      console.log(`${validHrLaps.length} laps with valid heart rate data`);

      if (validHrLaps.length >= 2) {
        const fastestLapHr = fastestLap.average_heartrate;
        const slowestLapHr = slowestLap.average_heartrate;
        console.log("HR comparison:", fastestLapHr, slowestLapHr);

        // Diff√©rence de FC d'au moins 10%
        hasSignificantHrDifference =
          fastestLapHr - slowestLapHr > slowestLapHr * 0.1;
        console.log(
          "Has significant HR difference?",
          hasSignificantHrDifference,
          `(${fastestLapHr - slowestLapHr} > ${slowestLapHr * 0.1})`
        );
      }
    }

    // 4. V√©rifier si un lap est significativement plus long
    const longestLap = significantLaps.reduce(
      (longest, lap) => (lap.distance > longest.distance ? lap : longest),
      significantLaps[0]
    );

    const hasSignificantLongLap =
      longestLap.distance > 3000 && longestLap.average_speed > avgSpeed;
    console.log(
      "Has significant long lap?",
      hasSignificantLongLap,
      `(${longestLap.distance}m at ${longestLap.average_speed}m/s)`
    );

    const result =
      hasSignificantSpeedDifference ||
      hasSignificantSpeedRatio ||
      hasSignificantHrDifference ||
      hasSignificantLongLap;

    console.log(
      "Final decision:",
      result ? "IS an interval workout" : "NOT an interval workout"
    );
    return result;
  } catch (error) {
    console.error("Erreur lors de l'analyse des laps:", error);
    // En cas d'erreur, s'en tenir √† la d√©tection par le nom
    return false;
  }
}

/**
 * Met √† jour la description et le titre d'une activit√©
 */
export async function updateActivityTitleAndDescription(
  accessToken,
  activityId,
  title,
  description
) {
  try {
    const response = await fetch(
      `https://www.strava.com/api/v3/activities/${activityId}`,
      {
        method: "PUT",
        headers: {
          Authorization: `Bearer ${accessToken}`,
          "Content-Type": "application/json",
        },
        body: JSON.stringify({
          name: title,
          description,
        }),
      }
    );

    if (!response.ok) {
      const errorData = await response.json();
      throw new Error(
        `Erreur API Strava: ${errorData.message || response.statusText}`
      );
    }

    return true;
  } catch (error) {
    console.error(
      "Erreur lors de la mise √† jour de l'activit√©:",
      error.message
    );
    throw error;
  }
}

/**
 * G√©n√®re une description d√©taill√©e de la s√©ance de fractionn√©
 */
export function generateWorkoutDescription(activity, laps) {
  // Extraire le format du fractionn√© du nom (ex: "5x4")
  const formatMatch = activity.name.match(/(\d+)\s*[xX]\s*\d+/);

  if (!formatMatch) {
    return activity.description || "";
  }

  const numIntervals = parseInt(formatMatch[1]);

  // Construire l'en-t√™te de la description
  let description = "";

  // Ajouter l'√©chauffement (premier lap) s'il existe
  if (laps.length > 0) {
    const warmupLap = laps[0];

    // Calculer l'allure pour l'√©chauffement
    const warmupPaceSeconds =
      warmupLap.average_speed > 0 ? 1000 / warmupLap.average_speed : 0;

    const warmupPaceMinutes = Math.floor(warmupPaceSeconds / 60);
    const warmupPaceRemainingSeconds = Math.floor(warmupPaceSeconds % 60);
    const warmupPaceFormatted = `${warmupPaceMinutes}:${warmupPaceRemainingSeconds
      .toString()
      .padStart(2, "0")}`;

    // Calculer la distance en km
    const warmupDistanceKm = (warmupLap.distance / 1000).toFixed(2);

    // Ajouter l'√©chauffement √† la description
    description += `üî• √âCHAUFFEMENT: ${warmupDistanceKm} km @ ${warmupPaceFormatted}/km\n\n`;
  }

  // Identifier la structure des intervalles (travail/r√©cup√©ration)
  // Supposons que apr√®s le lap d'√©chauffement, nous avons une alternance travail/r√©cup
  const workLaps = [];
  const recoveryLaps = [];

  // Identifier les laps d'effort et de r√©cup√©ration
  // Skip le premier lap (√©chauffement) et analysons le pattern
  for (let i = 1; i < laps.length - 1; i++) {
    // V√©rifier si nous sommes dans la partie intervalle (les laps courts/longs altern√©s)
    // Si le lap est significativement plus long que les intervalles pr√©c√©dents, c'est peut-√™tre le cooldown
    if (
      workLaps.length > 0 &&
      recoveryLaps.length > 0 &&
      laps[i].elapsed_time > 3 * recoveryLaps[0].elapsed_time &&
      workLaps.length >= numIntervals
    ) {
      // Ce lap est probablement le d√©but du cooldown
      break;
    }

    // Pattern typique: courts laps (efforts) suivis de laps plus longs (r√©cup)
    if (i % 2 === 1 && workLaps.length < numIntervals) {
      workLaps.push(laps[i]);
    } else if (i % 2 === 0 && recoveryLaps.length < numIntervals) {
      recoveryLaps.push(laps[i]);
    }
  }

  // D√©tecter le temps de r√©cup√©ration entre les intervalles
  let recoveryTime = "variable";
  if (recoveryLaps.length > 0) {
    // V√©rifier si la r√©cup√©ration est bas√©e sur le temps
    const firstRecovery = recoveryLaps[0].elapsed_time;
    const consistentTime = recoveryLaps.every(
      (lap) => Math.abs(lap.elapsed_time - firstRecovery) <= 5 // Tol√©rance de 5 secondes
    );

    if (consistentTime) {
      // Formater le temps de r√©cup√©ration selon sa dur√©e
      if (firstRecovery <= 60) {
        recoveryTime = `${firstRecovery}"`; // Format: 30"
      } else {
        const minutes = Math.floor(firstRecovery / 60);
        const seconds = firstRecovery % 60;
        recoveryTime =
          seconds > 0
            ? `${minutes}'${seconds.toString().padStart(2, "0")}"`
            : `${minutes}'`; // Format: 1'30"
      }
    } else {
      // V√©rifier si c'est une r√©cup√©ration bas√©e sur la distance
      const firstDistance = recoveryLaps[0].distance;
      const consistentDistance = recoveryLaps.every(
        (lap) => Math.abs(lap.distance - firstDistance) <= 20 // Tol√©rance de 20 m√®tres
      );

      if (consistentDistance) {
        recoveryTime = `${(firstDistance / 1000).toFixed(2)} km`;
      }
    }
  }

  // Ajouter les d√©tails de chaque intervalle d'effort
  description += `üèÉ INTERVALLES (R${recoveryTime}):\n`;

  workLaps.forEach((lap, index) => {
    // Calculer l'allure au km (min:sec/km)
    const paceSeconds = lap.average_speed > 0 ? 1000 / lap.average_speed : 0;

    const paceMinutes = Math.floor(paceSeconds / 60);
    const paceRemainingSeconds = Math.floor(paceSeconds % 60);
    const paceFormatted = `${paceMinutes}:${paceRemainingSeconds
      .toString()
      .padStart(2, "0")}`;

    // Formater la fr√©quence cardiaque
    const heartRate = lap.average_heartrate
      ? Math.round(lap.average_heartrate)
      : "N/A";

    description += `#${index + 1}: ${paceFormatted}/km  @${heartRate} bpm\n`;
  });

  // Calculer les moyennes globales
  const avgSpeed =
    workLaps.reduce((sum, lap) => sum + lap.average_speed, 0) / workLaps.length;
  const avgPaceSeconds = avgSpeed > 0 ? 1000 / avgSpeed : 0;
  const avgPaceMinutes = Math.floor(avgPaceSeconds / 60);
  const avgPaceRemainingSeconds = Math.floor(avgPaceSeconds % 60);
  const avgPaceFormatted = `${avgPaceMinutes}:${avgPaceRemainingSeconds
    .toString()
    .padStart(2, "0")}`;

  const avgHeartRate =
    workLaps.reduce((sum, lap) => sum + (lap.average_heartrate || 0), 0) /
    workLaps.length;
  const avgHeartRateFormatted = Math.round(avgHeartRate);

  description += `\nüìà MOYENNE: ${avgPaceFormatted}/km @${avgHeartRateFormatted} bpm`;

  // Identifier le cooldown
  // Chercher un lap plus long apr√®s les intervalles, ou fusionner les derniers laps
  let cooldownLap = null;
  let cooldownDistance = 0;
  let cooldownTime = 0;
  let cooldownHeartRate = 0;
  let cooldownSpeed = 0;
  let hasCooldown = false;

  // Chercher d'abord un lap unique et long qui pourrait √™tre le cooldown
  for (
    let i = workLaps.length + recoveryLaps.length + 1;
    i < laps.length;
    i++
  ) {
    const lap = laps[i];
    if (lap.elapsed_time >= 120) {
      // Au moins 2 minutes pour √™tre consid√©r√© comme cooldown
      hasCooldown = true;
      cooldownDistance += lap.distance;
      cooldownTime += lap.moving_time;
      cooldownHeartRate += lap.average_heartrate * lap.moving_time; // Moyenne pond√©r√©e par le temps
      cooldownSpeed += lap.average_speed * lap.moving_time; // Moyenne pond√©r√©e par le temps
    }
  }

  // Si on a trouv√© un cooldown
  if (hasCooldown && cooldownTime > 0) {
    // Calculer les moyennes
    cooldownHeartRate = cooldownHeartRate / cooldownTime;
    cooldownSpeed = cooldownSpeed / cooldownTime;

    // Calculer l'allure
    const cooldownPaceSeconds = cooldownSpeed > 0 ? 1000 / cooldownSpeed : 0;
    const cooldownPaceMinutes = Math.floor(cooldownPaceSeconds / 60);
    const cooldownPaceRemainingSeconds = Math.floor(cooldownPaceSeconds % 60);
    const cooldownPaceFormatted = `${cooldownPaceMinutes}:${cooldownPaceRemainingSeconds
      .toString()
      .padStart(2, "0")}`;

    // Ajouter le cooldown √† la description
    description += `\n\nüßä Cooldown : ${(cooldownDistance / 1000).toFixed(
      2
    )} km @ ${cooldownPaceFormatted}/km`;
  }

  return description;
}

/**
 * Analyse une activit√© sp√©cifique
 */
export async function analyzeActivity(accessToken, activity) {
  try {
    // V√©rifier si l'activit√© est √† traiter (un fractionn√©)
    if (!shouldProcessActivity(accessToken, activity)) {
      return {
        activity,
        success: true,
        message: `Activit√© "${activity.name}" ignor√©e - pas un fractionn√©`,
        processed: false,
      };
    }

    // R√©cup√©rer les d√©tails des laps (segments) de l'activit√©
    const laps = await getActivityLaps(accessToken, activity.id);

    // Analyser les donn√©es et cr√©er une nouvelle description
    const newDescription = generateWorkoutDescription(activity, laps);

    // Extraire les statistiques de la description pour le titre
    const stats = extractStatsFromDescription(newDescription);

    // G√©n√©rer le nouveau titre enrichi
    const newTitle = generateEnhancedTitle(activity.name, stats);

    // Mettre √† jour la description ET le titre de l'activit√©
    await updateActivityTitleAndDescription(
      accessToken,
      activity.id,
      newTitle,
      newDescription
    );

    // R√©cup√©rer l'activit√© mise √† jour avec la nouvelle description et le nouveau titre
    const updatedActivity = {
      ...activity,
      name: newTitle,
      description: newDescription,
      analyzed: true,
    };

    return {
      activity: updatedActivity,
      success: true,
      message: `Activit√© "${activity.name}" mise √† jour avec succ√®s`,
      processed: true,
    };
  } catch (error) {
    console.error(
      `Erreur lors de l'analyse de l'activit√© ${activity.id}:`,
      error.message
    );
    return {
      activity,
      success: false,
      message: error.message,
      processed: false,
      error: error.message,
    };
  }
}
